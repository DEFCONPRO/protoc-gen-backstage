package main

import (
	"bytes"
	"embed"
	"fmt"
	"log"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pseudomuto/protokit"
	"google.golang.org/protobuf/proto"

	"github.com/faceit/protoc-gen-backstage/proto/gen/go/efg/backstage"
)

//go:embed api.yaml.tmpl
var apiTemplate embed.FS

func main() {
	if err := protokit.RunPlugin(&plugin{}); err != nil {
		log.Fatal(err)
	}
}

type plugin struct{}

type PluginOptions struct {
	OutputFileName    string
	URLRoot           string
	RegexNameTemplate *regexp.Regexp
}

type API struct {
	Name               string
	FullName           string
	Owner              string
	Annotations        []*Annotation
	Lifecycle          string
	System             string
	DefinitionLocation string
}
type Annotation struct {
	Key   string
	Value string
}

func (p *plugin) Generate(req *plugin_go.CodeGeneratorRequest) (*plugin_go.CodeGeneratorResponse, error) {
	options, err := ParseOptions(req)
	if err != nil {
		return nil, err
	}

	descriptors := protokit.ParseCodeGenRequest(req)
	resp := new(plugin_go.CodeGeneratorResponse)

	for _, descriptor := range descriptors {
		content := "# Code generated by protoc-gen-backstage. DO NOT EDIT."
		if len(descriptor.Services) > 0 {
			for _, service := range descriptor.Services {
				serviceOptions := service.ServiceDescriptorProto.Options

				owner := proto.GetExtension(serviceOptions, backstage.E_Owner).(string)
				system := proto.GetExtension(serviceOptions, backstage.E_System).(string)

				var lifecycle = "production"
				deprecated := serviceOptions.GetDeprecated()
				if deprecated {
					lifecycle = "deprecated"
				}
				var annotations []*Annotation

				name := regexTemplateName(service.FullName, options.RegexNameTemplate)
				name = strings.Replace(name, ".", "-", -1)
				if len(name) > 63 {
					name = truncateTo63Chars(name)
					nameTooLongAnnotation := &Annotation{
						Key:   "originalName",
						Value: service.FullName,
					}
					annotations = append(annotations, nameTooLongAnnotation)
				}

				api := &API{
					Name:               name,
					FullName:           service.FullName,
					Annotations:        annotations,
					Lifecycle:          lifecycle,
					Owner:              owner,
					System:             system,
					DefinitionLocation: options.URLRoot + "/" + descriptor.GetName(),
				}

				buffer := new(bytes.Buffer)
				t := template.Must(template.ParseFS(apiTemplate, "*"))
				err = t.Execute(buffer, api)
				content += buffer.String()
			}

			dir := strings.Split(descriptor.GetName(), ".")[0] + "/"

			resp.File = append(resp.File, &plugin_go.CodeGeneratorResponse_File{
				Name:    proto.String(filepath.Join(dir, options.OutputFileName)),
				Content: proto.String(content),
			})
		}
	}

	return resp, nil
}

func truncateTo63Chars(name string) string {
	matchEndRegex := regexp.MustCompile("(.{0,63}$)")
	name = matchEndRegex.FindString(name)
	return name
}

func regexTemplateName(name string, regex *regexp.Regexp) string {
	matches := regex.FindStringSubmatch(name)
	defer func() {
		if err := recover(); err != nil {
			log.Println("regex didn't match service", name)
		}
	}()
	templatedName := strings.Join(matches[1:], "")
	return templatedName
}

func ParseOptions(req *plugin_go.CodeGeneratorRequest) (*PluginOptions, error) {
	options := &PluginOptions{
		OutputFileName:    "catalog-info.yaml",
		RegexNameTemplate: regexp.MustCompile("(.*)"),
	}

	params := req.GetParameter()

	if params == "" {
		return nil, fmt.Errorf("must provide root dir option")
	}

	parts := strings.Split(params, ",")
	if len(parts) < 1 || len(parts) > 3 {
		return nil, fmt.Errorf("invalid parameter: %s, must be 1-3 options", params)
	}

	if parts[0] == "" {
		return nil, fmt.Errorf("must provide root dir option")
	}
	options.URLRoot = parts[0]

	if len(parts) > 1 && parts[1] != "" {
		options.OutputFileName = parts[1]
	}

	if len(parts) > 2 && parts[2] != "" {
		regexNameTemplate, err := regexp.Compile(parts[2])
		if err != nil {
			return nil, fmt.Errorf("third option must be regex")
		}
		options.RegexNameTemplate = regexNameTemplate
	}

	return options, nil
}
