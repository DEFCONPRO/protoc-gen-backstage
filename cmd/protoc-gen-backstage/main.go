package main

import (
	"fmt"
	"log"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/pseudomuto/protokit"
	"google.golang.org/protobuf/proto"

	"github.com/faceit/protoc-gen-backstage/proto/gen/go/github.com/faceit/protoc-gen-backstage/efg/backstage"
)

func main() {
	if err := protokit.RunPlugin(&plugin{}); err != nil {
		log.Fatal(err)
	}
}

type plugin struct{}

type PluginOptions struct {
	OutputFile string
	Root       string
}

func (p *plugin) Generate(req *plugin_go.CodeGeneratorRequest) (*plugin_go.CodeGeneratorResponse, error) {
	options, err := ParseOptions(req)
	if err != nil {
		return nil, err
	}

	descriptors := protokit.ParseCodeGenRequest(req)
	resp := new(plugin_go.CodeGeneratorResponse)

	for _, descriptor := range descriptors {
		content := "# Code generated by protoc-gen-backstage. DO NOT EDIT."
		if len(descriptor.Services) > 0 {
			for _, service := range descriptor.Services {
				serviceOptions := service.ServiceDescriptorProto.Options
				owner := proto.GetExtension(serviceOptions, backstage.E_Owner).(string)
				system := proto.GetExtension(serviceOptions, backstage.E_System).(string)

				var lifecycle = "production"
				deprecated := serviceOptions.GetDeprecated()
				if deprecated {
					lifecycle = "deprecated"
				}

				var nameTooLong = false
				name := strings.Replace(service.FullName, ".", "-", -1)
				if len(name) > 63 {
					nameTooLong = true
					name = truncateTo63Chars(name)
				}

				if owner == "" {
					content += `
# Owner is a required field your Service "` + service.FullName + `" must implement the custom option
# See github.com/faceit/protoc-gen-backstage for more info
`
				} else {
					content += `
---
apiVersion: backstage.io/v1alpha1
kind: API
metadata:
  name: ` + name
					if nameTooLong {
						content += `
  annotations:
    originalName: ` + service.FullName
					}
					content += `
spec:
  type: grpc
  lifecycle: ` + lifecycle +
						`
  owner: ` + owner

					if system != "" {
						content += `
  system: " + system
`
					}
					content += `
  definition:
    $text: ` + options.Root + "/" + descriptor.GetName() + `
`
				}
			}

			dir := strings.Split(descriptor.GetName(), ".")[0] + "/"

			resp.File = append(resp.File, &plugin_go.CodeGeneratorResponse_File{
				Name:    proto.String(filepath.Join(dir, options.OutputFile)),
				Content: proto.String(content),
			})
		}
	}

	return resp, nil
}

func truncateTo63Chars(name string) string {
	matchEndRegex := regexp.MustCompile("(.{0,63}$)")
	name = matchEndRegex.FindString(name)
	return name
}

func ParseOptions(req *plugin_go.CodeGeneratorRequest) (*PluginOptions, error) {
	options := &PluginOptions{OutputFile: "catalog-info.yaml"}

	params := req.GetParameter()

	if params == "" {
		return nil, fmt.Errorf("must provide root dir option")

	}

	parts := strings.Split(params, ",")
	if len(parts) < 1 || len(parts) > 2 {
		return nil, fmt.Errorf("invalid parameter: %s", params)
	}

	if parts[0] == "" {
		return nil, fmt.Errorf("must provide root dir")
	}
	options.Root = parts[0]

	if parts[1] != "" {
		options.OutputFile = parts[1]
	}

	return options, nil
}
