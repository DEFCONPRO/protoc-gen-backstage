package main

import (
	"flag"
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/faceit/protoc-gen-backstage/gen/proto/go/github.com/faceit/protoc-gen-backstage/custom_options"
)

func main() {
	var (
		flags    flag.FlagSet
		filename = flags.String(
			"filename",
			"catalog-info.yaml",
			"filename for the backstage config files")
	)

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f, filename)
		}
		return nil
	})
}

// generateFile generates a backstage file containing api definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File, filename *string) *protogen.GeneratedFile {
	path := fmt.Sprintf("%s/%s", file.GeneratedFilenamePrefix, *filename)
	g := gen.NewGeneratedFile(path, file.GoImportPath)
	g.P("# Code generated by protoc-gen-backstage. DO NOT EDIT.")
	for _, service := range file.Services {
		options := service.Desc.Options().(*descriptorpb.ServiceOptions)
		owner := proto.GetExtension(options, custom_options.E_Owner).(string)
		system := proto.GetExtension(options, custom_options.E_System).(string)
		// owner is a required field so skip if it doesn't exist
		if owner == "" {
			continue
		}
		file.Proto.String()
		//service.
		g.P("---")
		g.P("apiVersion: backstage.io/v1alpha1")
		g.P("kind: API")
		g.P("metadata:")
		g.P("  name: ", service.GoName)
		g.P("spec:")
		g.P("  type: grpc")
		g.P("  owner: ", owner)
		if system != "" {
			g.P("  system: ", system)
		}
		g.P("  definition:")
		g.P("    $text: ./proto/", file.GeneratedFilenamePrefix, ".proto")
		g.P()
	}
	return g
}
